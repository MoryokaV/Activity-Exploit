#!/usr/bin/env python3

from datetime import datetime
import numpy as np
from PIL import Image
from PIL import ImageGrab
import pickle
import cv2

class Screenshot():
    def __init__(self, sock):
        self.sock = sock

    def take_screenshot(self):
        screen = np.array(ImageGrab.grab()) #take screenshot 
        data = pickle.dumps(screen) #serialize

        #send screenshot to server
        while True:
            status = self.sock.recv(1024).decode()
            
            if status == "SIZE":
                self.sock.send(str(len(data)).encode())
            elif status == "STREAM":
                self.sock.sendall(data)  
                break
        
    def download_screenshot(self):
        conn = self.sock

        print("\nGathering information...")
        conn.send("SIZE".encode())
        filesize = int(conn.recv(1024).decode())
        
        date = datetime.now().strftime("%d-%m-%Y %H'%M'%S")
        filename = "Screenshot_" + date + ".png"   

        print("Allocating memory...") 
        conn.send("STREAM".encode())
        
        data = b''
        while len(data) < filesize:
            data += conn.recv(65536) #64Kb chunk
            print("{0:.2f}".format((len(data) / float(filesize)) * 100) + "% Done...", end = "\r")
        
        img = Image.fromarray(pickle.loads(data)) #converting numpy to PIL.Image
        img.save(filename) #save image to disk

        print("\nScreenshot received!\n")

class ShareScreen():
    def __init__(self, sock, width, height):
        self.sock = sock
        self.width = width
        self.height = height

    def sendScreen(self):
        while True:
            screen = np.array(ImageGrab.grab()) #take screenshot
            
            if self.width > 1920 and self.height > 1080:
                img = cv2.resize(screen, dsize=(1920, 1080), interpolation=cv2.INTER_CUBIC) #resize image to FHD (optimize speed)
            else:
                img = screen

            data = pickle.dumps(img)
            while True:
                status = self.sock.recv(1024).decode()
                
                if status == "SIZE":
                    self.sock.send(str(len(data)).encode())
                elif status == "STREAM":
                    self.sock.sendall(data)
                    break
                elif status == "STOP":
                    return

    def receiveScreen(self):
        conn = self.sock
        cv2.namedWindow('Client Screen', cv2.WINDOW_NORMAL) #setting the window resizeable

        while True:
            conn.send("SIZE".encode())
            size = int(conn.recv(1024).decode())
            
            conn.send("STREAM".encode())
            
            data = b''
            while len(data) < size:
                data += conn.recv(65536) #64Kb buffer
            
            #maintain the original colors from array
            imageRGB = cv2.cvtColor(pickle.loads(data), cv2.COLOR_BGR2RGB)

            #display frame
            cv2.imshow('Client Screen', imageRGB)

            if cv2.waitKey(1) == ord('q'):
                cv2.destroyAllWindows()
                conn.send("STOP".encode())
                return
