#!/usr/bin/env python3

from datetime import datetime
from mss import mss
import numpy as np
from PIL import Image
import pickle
import cv2

class Screenshot():
    def __init__(self, sock):
        self.sock = sock

    def take_screenshot(self):
        #selecting the area of the screen to be captured
        trigger = {'top': 0, 'left': 0, 'width': 1280, 'height': 720}
        
        #taking screenshot
        screen = np.array(mss().grab(trigger))
        data = pickle.dumps(screen) #serialize

        #send screenshot to server
        while True:
            status = self.sock.recv(1024).decode()
            
            if status == "SIZE":
                self.sock.send(str(len(data)).encode())
            elif status == "STREAM":
                self.sock.sendall(data)  
                break
        
    def download_screenshot(self):
        conn = self.sock

        print("\nGathering information...")
        conn.send("SIZE".encode())
        filesize = int(conn.recv(1024).decode())
        
        date = datetime.now().strftime("%d-%m-%Y %H'%M'%S")
        filename = "Screenshot_" + date + ".png"   

        print("Allocating memory...") 
        conn.send("STREAM".encode())
        
        data = b''
        while len(data) < filesize:
            data += conn.recv(8192) #8Kb chunk
            print("{0:.2f}".format((len(data)/float(filesize)) * 100) + "% Done...", end = "\r")
        
        #maintain the original colors from array
        imageRGB = cv2.cvtColor(pickle.loads(data), cv2.COLOR_BGR2RGB)
        
        #save RGB array to disk
        img = Image.fromarray(imageRGB)
        img.save(filename)

        print("\nScreenshot received!\n")

class ShareScreen():
    def __init__(self, sock):
        self.sock = sock

    def sendScreen(self):
        trigger = {'top': 0, 'left': 0, 'width': 1280, 'height': 720} 
            
        while True:
            img = np.array(mss().grab(trigger))
            data = pickle.dumps(img)

            while True:
                status = self.sock.recv(1024).decode()
                print(status)
                if status == "SIZE":
                    self.sock.send(str(len(data)).encode())
                elif status == "STREAM":
                    self.sock.sendall(data)
                    break
                elif status == "STOP":
                    return

    def receiveScreen(self):
        conn = self.sock
        
        while True:
            conn.send("SIZE".encode())
            size = int(conn.recv(1024).decode())
            
            conn.send("STREAM".encode())
            
            data = b''
            while len(data) < size:
                data += conn.recv(65536) #64Kb buffer

            cv2.imshow('Client Screen', pickle.loads(data))

            if cv2.waitKey(1) == ord('q'):
                cv2.destroyAllWindows()
                conn.send("STOP".encode())
                return
